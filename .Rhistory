strip.background = element_rect(fill = "#000080"),
panel.background = element_rect(fill = "#f3faff"), panel.grid.major = element_line(colour = "white"),
panel.spacing = unit(2, "lines")
)
options(ggplot2.discrete.fill = list("#67c5a7"))
Dark2 = paletteer_d("RColorBrewer::Dark2")
# files from the ALFAM2 zenodo repository
data_interval_level = read.csv(file = "data/ALFAM2_interval.csv")
data_plot_level = read.csv(file = "data/ALFAM2_plot.csv")
# files from the supplementary material of Hafner et al (2019)
evaluation_subset_pmids = read.csv(file = "data/1-s2.0-S1352231018308069-mmc2.csv")
calibration_subset_pmids = read.csv(file = "data/1-s2.0-S1352231018308069-mmc1.csv")
df_pmids = rbind (evaluation_subset_pmids %>% mutate (dataset = "Evaluation subset"),
calibration_subset_pmids %>% mutate (dataset = "Calibration subset"))
head (df_pmids, n = 3) %>% kable (align = c ("l", "r"))
df_pmids %>% count (dataset) %>% kable (align = c ("l", "r"))
data = data_interval_level %>%
# keeping only the same trial as in Hafner et al (2019)
filter (pmid %in% df_pmids$pmid) %>%
# adding the 'dataset' variable (either 'Calibration subset' or 'Evaluation subset')
left_join (df_pmids, by = "pmid") %>%
# removing measurements made after more than 78h after fertilizer application
filter (ct <= 78) %>%
# selecting variables of interest
select (e.cum, j.NH3, pmid, ct, dt, air.temp, wind.2m, rain.rate, rain.cum, dataset)  %>%
# adding plot level informations
left_join (
data_plot_level %>%
filter (pmid %in% df_pmids$pmid) %>%
select (pmid, country, meas.tech, tan.app, app.method, app.rate, man.dm, man.ph, man.source, incorp, time.incorp) %>%
rename (app.mthd = app.method, t.incorp = time.incorp),
by = "pmid"
) %>%
# dealing with NAs for the rain
replace_na (list (rain.rate = 0)) %>%
replace_na (list (rain.cum = 0)) %>%
# dealing with NAs for the wind and the temperature
mutate (wind.2m = replace_na (wind.2m, mean (wind.2m, na.rm = TRUE)), .by = pmid) %>%
mutate (air.temp = replace_na (air.temp, mean (air.temp, na.rm = TRUE)), .by = pmid) %>%
# recoding time of incorporation values that are below 0.25 : setting them to 0
mutate (t.incorp = ifelse (t.incorp <= 0.25, 0, t.incorp)) %>%
# setting time of incorporation to 1000 in the case of no incorporation
mutate (t.incorp = ifelse (t.incorp == 0 & incorp == "none", 1000, t.incorp)) %>%
mutate (t.incorp = replace_na (t.incorp, 1000)) %>%
# dealing with NAs for the pH
mutate (man.ph = replace_na (man.ph, median (man.ph, na.rm = TRUE)), .by = man.source) %>%
rename (time = ct) %>%
mutate_if (is.character, as.factor) %>%
{.}
data_predictions = data
head (data) %>% kable
data %>%
filter (pmid %in% unique (data$pmid)[c (1, 101, 201, 301, 401, 501)]) %>%
ggplot() +
geom_point (aes (x = time, y = e.cum)) +
geom_line (aes (x = time, y = e.cum)) +
facet_wrap (~ pmid, scales = "free", ncol = 2) +
xlab ("Time after fertilizer application (h)") +
ylab ("Cumul of ammonia volatilization (kg/ha)")
data_tmp = data %>% filter (pmid == data$pmid[1])
data_tmp %>% kable
data_tmp = rbind (data_tmp [1, ], data_tmp)
data_tmp$e.cum[1] = 0
data_tmp$time[1] = 0
data_tmp %>% kable
max_dt = max (data_tmp$time)
DT = 2
seq_time = seq (0, max_dt - 1e-6 + DT, by = DT)
seq_time
# with the argument 'rule = 2' in the approx function, the values at times outside the range of observation are set to the value at the closest data extreme
# for example, here, the value for time = 46 are the observed values at time  = 44.75
app.e.cum = approx (data_tmp$time, data_tmp$e.cum, xout = seq_time, rule = 2)
app.air.temp = approx (data_tmp$time, data_tmp$air.temp, xout = seq_time, rule = 2)
app.wind = approx (data_tmp$time, data_tmp$wind.2m, xout = seq_time, rule = 2)
app.rain = approx (data_tmp$time, data_tmp$rain.rate, xout = seq_time, rule = 2)
app.e.cum
data_tmp = data.frame (
time = seq_time,
e.cum = app.e.cum$y,
air.temp = app.air.temp$y,
wind.2m = app.wind$y,
rain.rate = app.rain$y,
pmid = data_tmp$pmid[1],
dataset = data_tmp$dataset[1],
country = data_tmp$country[1],
meas.tech = data_tmp$meas.tech[1],
tan.app = data_tmp$tan.app[1],
app.mthd = data_tmp$app.mthd[1],
app.rate = data_tmp$app.rate[1],
man.dm = data_tmp$man.dm[1],
man.ph = data_tmp$man.ph[1],
man.source = data_tmp$man.source[1],
incorp = data_tmp$incorp[1],
t.incorp = data_tmp$t.incorp[1]
)
head (data_tmp, n = 3) %>% kable
data_tmp = data_tmp [- 1, ] %>% `rownames<-` (NULL)
data_tmp$e.cum_shift = c (0, data_tmp$e.cum [c (1 : (nrow (data_tmp) - 1))])
data_tmp = data_tmp %>% relocate (e.cum_shift, .after = e.cum)
head (data_tmp, n = 3) %>% kable
pmids = data$pmid %>% unique
DT = 2
interpolated_data = NULL
for (i in c (1 : length (pmids))){
data_tmp = data %>% filter (pmid == pmids[i])
data_tmp = rbind (data_tmp [1, ], data_tmp)
data_tmp$e.cum[1] = 0
data_tmp$time[1] = 0
max_dt = max (data_tmp$time)
seq_time = seq (0, max_dt - 1e-6 + DT, by = DT)
app.e.cum = approx (data_tmp$time, data_tmp$e.cum, xout = seq_time, rule = 2)
app.air.temp = approx (data_tmp$time, data_tmp$air.temp, xout = seq_time, rule = 2)
app.wind = approx (data_tmp$time, data_tmp$wind.2m, xout = seq_time, rule = 2)
app.rain = approx (data_tmp$time, data_tmp$rain.rate, xout = seq_time, rule = 2)
data_tmp = data.frame (
time = seq_time,
e.cum = app.e.cum$y,
air.temp = app.air.temp$y,
wind.2m = app.wind$y,
rain.rate = app.rain$y,
pmid = data_tmp$pmid[1],
dataset = data_tmp$dataset[1],
country = data_tmp$country[1],
meas.tech = data_tmp$meas.tech[1],
tan.app = data_tmp$tan.app[1],
app.mthd = data_tmp$app.mthd[1],
app.rate = data_tmp$app.rate[1],
man.dm = data_tmp$man.dm[1],
man.ph = data_tmp$man.ph[1],
man.source = data_tmp$man.source[1],
incorp = data_tmp$incorp[1],
t.incorp = data_tmp$t.incorp[1]
)
data_tmp = data_tmp [- 1, ]
data_tmp$e.cum_shift = c (0, data_tmp$e.cum [c (1 : (nrow (data_tmp) - 1))])
data_tmp = data_tmp %>% relocate (e.cum_shift, .after = e.cum)
interpolated_data = rbind (interpolated_data, data_tmp)
}
interpolated_data %>%
filter (pmid %in% unique (data$pmid)[c (1, 101, 201, 301, 401, 501)]) %>%
ggplot() +
geom_point (aes (x = time, y = e.cum)) +
geom_line (aes (x = time, y = e.cum)) +
facet_wrap (~ pmid, scales = "free", ncol = 2) +
xlab ("Time after fertilizer application (h)") +
ylab ("Cumul of ammonia volatilization (kg/ha)")
data_calibration = interpolated_data %>%
filter (dataset == "Calibration subset") %>%
select (- pmid, - dataset, - country, - meas.tech)
head (data_calibration, n = 3) %>% kable
# set.seed (123)
#
# t0 = Sys.time()
# model_random_forest = randomForest (
#         e.cum ~ .,
#         data = data_calibration,
#         importance = TRUE
# )
#
# t1 = Sys.time()
# difftime (t1, t0)
#
# save (model_random_forest, file = "saved_results/model_random_forest.Rdata")
load (file = "saved_results/model_random_forest.Rdata")
# filtering the first trial, creating e.cum_hat to store the predictions and setting e.cum_shift to NA
data_tmp = interpolated_data %>%
filter (pmid == pmids[1]) %>%
mutate (e.cum_hat = NA, e.cum_shift = NA, .after = "e.cum") %>%
head (n = 3)
data_tmp %>% kable
# Making the predictions recursively
n = nrow (data_tmp)
prediction = 0
for (j in c (1 : n)){
data_tmp$e.cum_shift[j] = prediction
newdata = data_tmp [j, ] %>% select (- pmid, - e.cum, - dataset, - country, - meas.tech, - e.cum_hat)
prediction = predict (model_random_forest, newdata = newdata)
data_tmp$e.cum_hat [j] = prediction
}
data_tmp %>% kable
# df_predictions_random_forest = NULL
#
# t0 = Sys.time()
# for (i in c (1 : length (pmids))){
#
#     data_tmp = interpolated_data %>%
#       filter (pmid == pmids[i]) %>%
#       mutate (e.cum_hat = NA, e.cum_shift = NA, .after = "e.cum")
#
#     n = nrow (data_tmp)
#     prediction = 0
#
#     for (j in c (1 : n)){
#         data_tmp$e.cum_shift[j] = prediction
#         newdata = data_tmp [j, ] %>% select (- pmid, - e.cum, - dataset, - country, - meas.tech, - e.cum_hat)
#         prediction = predict (model_random_forest, newdata = newdata)
#         data_tmp$e.cum_hat [j] = prediction
#     }
#
#     df_predictions_random_forest = rbind (df_predictions_random_forest, data_tmp)
# }
# t1 = Sys.time()
# difftime (t1, t0)
#
# save (df_predictions_random_forest, file = "saved_results/df_predictions_random_forest.Rdata")
load (file = "saved_results/df_predictions_random_forest.Rdata")
interpolated_e.cum = NULL
for (i in c (1 : length (pmids))){
data_tmp = df_predictions_random_forest %>% filter (pmid == pmids[i])
# adding a row with e.cum = 0 at time 0, usefull for the interpolation of times < DT
data_tmp = rbind (
data_tmp [1, ] %>% mutate (e.cum_hat = 0, time = 0),
data_tmp
)
time = data %>% filter (pmid == pmids[i]) %>% pull (time)
interpolation = approx (data_tmp$time, data_tmp$e.cum_hat, xout = time)
interpolated_e.cum = c (interpolated_e.cum, interpolation$y)
}
data_predictions = data_predictions %>%
mutate (e.cum_hat_random_forest = interpolated_e.cum, .after = e.cum)  %>%
mutate (e.cum_shift_hat_random_forest = c (0, e.cum_hat_random_forest [1 : (n() - 1)]), .by = pmid, .after = e.cum) %>%
mutate (j.NH3_hat_random_forest = (e.cum_hat_random_forest - e.cum_shift_hat_random_forest) / dt, .after = j.NH3) %>%
select (- e.cum_shift_hat_random_forest)
data_predictions %>%
filter (time == max (time), .by = pmid) %>%
select (prediction = e.cum_hat_random_forest, truth = e.cum, dataset) %>%
mutate (type = "Cumulative emissions") %>%
dplyr::summarise (
rmse = sqrt (mean ((prediction - truth) ^ 2)),
Pearsons_r = cor (prediction, truth),
ME = 1 - (sum ((prediction - truth) ^ 2) / sum ((truth - mean (truth)) ^ 2)),
MAE = mean (abs (prediction - truth)),
MBE = mean (prediction - truth),
.by = c (type, dataset)
) %>%
mutate_if (is.numeric, round, digits = 3) %>% kable
data_predictions %>%
select (prediction = j.NH3_hat_random_forest, truth = j.NH3, dataset) %>%
mutate (type = "Flux") %>%
dplyr::summarise (
rmse = sqrt (mean ((prediction - truth) ^ 2)),
Pearsons_r = cor (prediction, truth),
ME = 1 - (sum ((prediction - truth) ^ 2) / sum ((truth - mean (truth)) ^ 2)),
MAE = mean (abs (prediction - truth)),
MBE = mean (prediction - truth),
.by = c (type, dataset)
) %>%
mutate_if (is.numeric, round, digits = 3) %>% kable
alfam2_predictions =  alfam2 (
pars = alfam2pars01,
dat = data %>% select (- j.NH3, - e.cum, - dt, - dataset, - country, - meas.tech, - man.ph),
app.name = "tan.app",
time.name = "time",
time.incorp = "t.incorp",
group = "pmid",
prep = TRUE,
warn = FALSE
)
alfam2_predictions = alfam2_predictions %>%
select (pmid, time, j, e) %>%
mutate (truth_j = data$j.NH3) %>%
mutate (truth_e = data$e.cum) %>%
mutate (dataset = data$dataset) %>%
select (pmid, time, j, e, truth_j, truth_e, dataset)
data_predictions = data_predictions %>%
mutate (e.cum_hat_ALFAM2 = alfam2_predictions$e,
j.NH3_hat_ALFAM2 = alfam2_predictions$j,
.after = e.cum)
df_predictions_for_evaluation_metrics = rbind (
# flux --------
alfam2_predictions %>%
select (truth = truth_j, prediction = j, dataset) %>%
mutate (response = "flux"),
# cumulative emission --------
alfam2_predictions %>%
filter (time == max (time), .by = pmid) %>%
select (truth = truth_e, prediction = e, dataset) %>%
mutate (response = "72h cum. emission")
)
df_predictions_for_evaluation_metrics %>%
summarise (
Pearsons_r = cor (prediction, truth),
ME = 1 - (sum ( (prediction - truth) ^ 2) / sum ( (truth - mean (truth)) ^ 2)),
MAE = mean (abs (prediction - truth)),
MBE = mean (prediction - truth),
.by = c (dataset, response)
) %>%
mutate_if (is.numeric, round, digits = 3) %>%
arrange (desc (dataset)) %>% kable
data_calibration_nn = interpolated_data %>%
filter (dataset == "Calibration subset") %>%
select (- pmid, - dataset, - country, - meas.tech)  %>%
mutate (app.mthd = as.numeric (recode (app.mthd, "bc" = 0, "bsth" = 1, "os" = 2, "ts" = 3))) %>%
mutate (man.source = as.numeric (recode (man.source, "pig" = 0, "cat" = 1))) %>%
mutate (incorp = as.numeric (recode (incorp, "none" = 0, "shallow" = 1, "deep" = 2)))
x_train = as.matrix (data_calibration_nn %>% select (- e.cum))
y_train = data_calibration_nn$e.cum
library(keras3)
library(tensorflow)
set_random_seed(123)
model_nn <- keras_model_sequential() %>%
layer_dense(units = 64, activation = 'relu', input_shape = ncol(x_train)) %>%
layer_dense(units = 32, activation = 'relu') %>%
layer_dense(units = 16, activation = 'relu') %>%
layer_dense(units = 8, activation = 'relu') %>%
layer_dense(units = 4, activation = 'relu') %>%
layer_dense(units = 1)
model_nn %>% compile(
loss = 'mean_squared_error',
optimizer = optimizer_adam(),
metrics = list('mean_absolute_error')
)
summary(model_nn)
dim (x_train)
history <- model_nn %>% fit(
x = x_train,
y = y_train,
epochs = 500,
batch_size = 15464,
validation_split = 0.2,
verbose = 0
)
plot (history) +
theme (legend.position = "bottom")
df_predictions_neural_network = NULL
t0 = Sys.time()
for (i in c (1 : length (pmids))){
# for (i in c (1 : 10)){
if (((i / 10) - round (i / 10)) == 0) {print (i)}
data_tmp = interpolated_data %>%
mutate (app.mthd = as.numeric (recode (app.mthd, "bc" = 0, "bsth" = 1, "os" = 2, "ts" = 3))) %>%
mutate (man.source = as.numeric (recode (man.source, "pig" = 0, "cat" = 1))) %>%
mutate (incorp = as.numeric (recode (incorp, "none" = 0, "shallow" = 1, "deep" = 2))) %>%
filter (pmid == pmids[i]) %>%
mutate (e.cum_hat = NA, e.cum_shift = NA, .after = "e.cum")
n = nrow (data_tmp)
pred = 0
for (j in c (1 : n)){
newdata = data_tmp [j, ] %>% select (- pmid, - e.cum, - dataset, - country, - meas.tech, - e.cum_hat)
newdata$e.cum_shift [1] = pred
pred = predict (model_nn, x = as.matrix (newdata), verbose = FALSE)
data_tmp$e.cum_hat [j] = pred
}
df_predictions_neural_network = rbind (df_predictions_neural_network, data_tmp)
}
t1 = Sys.time()
difftime (t1, t0)
save (df_predictions_neural_network, file = "saved_results/df_predictions_neural_network.Rdata")
load (file = "saved_results/df_predictions_neural_network.Rdata")
interpolated_e.cum = NULL
for (i in c (1 : length (pmids))){
data_tmp = df_predictions_neural_network %>% filter (pmid == pmids[i])
# adding a row with e.cum = 0 at time 0, usefull for the interpolation of times < DT
data_tmp = rbind (
data_tmp [1, ] %>% mutate (e.cum_hat = 0, time = 0),
data_tmp
)
time = data %>% filter (pmid == pmids[i]) %>% pull (time)
interpolation = approx (data_tmp$time, data_tmp$e.cum_hat, xout = time)
interpolated_e.cum = c (interpolated_e.cum, interpolation$y)
}
data_predictions = data_predictions %>%
mutate (e.cum_hat_nn = interpolated_e.cum, .after = e.cum)  %>%
mutate (e.cum_shift_hat_nn = c (0, e.cum_hat_nn [1 : (n() - 1)]), .by = pmid, .after = e.cum) %>%
mutate (j.NH3_hat_nn = (e.cum_hat_nn - e.cum_shift_hat_nn) / dt, .after = j.NH3) %>%
select (- e.cum_shift_hat_nn)
data_predictions %>%
filter (time == max (time), .by = pmid) %>%
select (prediction = e.cum_hat_nn, truth = e.cum, dataset) %>%
mutate (type = "Cumulative emissions") %>%
dplyr::summarise (
rmse = sqrt (mean ((prediction - truth) ^ 2)),
Pearsons_r = cor (prediction, truth),
ME = 1 - (sum ((prediction - truth) ^ 2) / sum ((truth - mean (truth)) ^ 2)),
MAE = mean (abs (prediction - truth)),
MBE = mean (prediction - truth),
.by = c (type, dataset)
) %>%
mutate_if (is.numeric, round, digits = 3) %>% kable
data_predictions %>%
select (prediction = j.NH3_hat_nn, truth = j.NH3, dataset) %>%
mutate (type = "Flux") %>%
dplyr::summarise (
rmse = sqrt (mean ((prediction - truth) ^ 2)),
Pearsons_r = cor (prediction, truth),
ME = 1 - (sum ((prediction - truth) ^ 2) / sum ((truth - mean (truth)) ^ 2)),
MAE = mean (abs (prediction - truth)),
MBE = mean (prediction - truth),
.by = c (type, dataset)
) %>%
mutate_if (is.numeric, round, digits = 3) %>% kable
data_predictions %>%
filter (pmid %in% c (1685, 974, 1232, 1504, 1450, 584)) %>%
select (e.cum, e.cum_hat_random_forest, e.cum_hat_ALFAM2, time, pmid) %>%
pivot_longer (cols = c (e.cum, e.cum_hat_random_forest, e.cum_hat_ALFAM2)) %>%
mutate (name = recode (name,
"e.cum" = "Observed values",
"e.cum_hat_ALFAM2" = "ALFAM2",
"e.cum_hat_random_forest" = "Random forest")) %>%
mutate (name = factor (name, levels = c ("Observed values", "ALFAM2", "Random forest"))) %>%
ggplot () +
geom_point (aes (x = time, y = value, color = name), size = 3) +
geom_line (aes (x = time, y = value, color = name), linewidth = 0.75) +
facet_wrap (~ pmid, scales = "free", ncol = 2) +
theme (legend.position = "bottom") +
ylab ("Cumulative emissions (kg/ha)") +
xlab ("Time after fertilizer application") +
ggtitle ("Observed vs predicted values for some trials") +
labs (color = "")
setwd("~/Documents/Vie_pro/Expériences/2023-11-01_These/codes/formations/finistR_2024/packaging_test")
getwd()
library (devtools)
packageVersion("devtools")
#> [1] '2.4.5'
setwd("~/")
create_package("~/")
create_package("~/regexcite/")
create_package("~/allo/")
create_package("~/Documents/allo/")
here::dr_here()
create_package("~/allo/")
create_package("~/regexcite/")
library (future)
library (progressr)
plan(multisession, workers = 4)
setwd("~/Documents/Vie_pro/Expériences/Papers/machine_learning_approaches_for_ammonia_volatilization_prediction_after_manure_application")
# Options pour le rmarkdown
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library ("readxl") # version 1.4.3
library ("ggplot2") # version 3.4.4
library ("gridExtra") # version 2.3
library ("dplyr") # version 1.1.2
library ("paletteer") # version 1.4.0
library ("tibble") # version 3.2.1
library ("tidyr") # version 1.3.0
library ("ALFAM2") # version 3.7
library ("randomForest") # version 4.7.1.1
library ("xgboost") # version 1.7.6.1
library ("glmnet") # version 4.1.8
library ("treeshap") # version 0.3.1
library ("shapviz") # version 0.9.3
library ("kableExtra") # version 1.3.4
axis_text_size = 22
axis_title_size = 26
title_size = 26
theme_replace(
axis.text = element_text(size = axis_text_size),
axis.title.x = element_text(size = axis_title_size, angle = 0, margin = ggplot2::margin (t = 10)),
axis.title.y = element_text(size = axis_title_size, angle = 90, margin = ggplot2::margin (r = 10)),
plot.title = element_text(size = title_size, hjust = 0.5, face = "bold"),
legend.text = element_text(size = axis_title_size),
legend.title = element_text(size = axis_title_size, face = "bold"),
strip.text = element_text(size = axis_title_size, face = "bold", color = "white"),
strip.background = element_rect(fill = "#000080"),
panel.background = element_rect(fill = "#f3faff"), panel.grid.major = element_line(colour = "white"),
panel.spacing = unit(2, "lines")
)
options(ggplot2.discrete.fill = list("#67c5a7"))
Dark2 = paletteer_d("RColorBrewer::Dark2")
load (file = "scripts/processed_data/data_alfam2.Rdata")
data_alfam2 %>% summarise (n = n(), .by = dataset)
Figure_1 = data_alfam2 %>%
filter (! (app.mthd == "bsth" & incorp == "shallow")) %>%
mutate (strategy = paste (app.mthd, incorp, sep = " - ")) %>%
mutate (strategy = recode (strategy, "bc - none" = "A", "bc - shallow" = "B", "bc - deep" = "C", "bsth - none" = "D", "os - none" = "E", "ts - none" = "F")) %>%
ggplot () +
geom_line (aes (x = time, y = e.rel, group = pmid), linewidth = 0.15) +
ylab ("Cumulative emission (frac. applied TAN)") +
xlab ("Time (h)") +
theme (axis.title.y = element_text (margin = ggplot2::margin (r = 25)),
strip.text.x = element_text(margin = ggplot2::margin(t = 8, b = 8, r = 0, l = 0))) +
# scale_color_manual (values = Dark2) +
facet_wrap (~ strategy)
Figure_1
tiff (file = "figures/Figure_1.tiff", width = 1000, height = 700)
Figure_1
dev.off()
data_alfam2 %>%
select (air.temp, wind.2m, rain.rate, rain.cum) %>%
summary
data_alfam2 %>%
filter (time == max (time), .by = pmid) %>%
select (e.cum, time, tan.app, app.rate, man.dm, man.ph, t.incorp) %>%
summary
# We use alfam2pars01 parameter without pH, like in Hafner et al, 2019
pars <- alfam2pars01[!grepl('man.ph', names(alfam2pars01))]
alfam2_predictions =  alfam2 (
pars = pars,
dat = data_alfam2 %>% select (- j.NH3, - e.cum, - e.rel, - dataset, - country),
app.name = "tan.app",
time.name = "time",
time.incorp = "t.incorp",
group = "pmid",
prep = TRUE,
warn = FALSE
)
# We use alfam2pars01 parameter without pH, like in Hafner et al, 2019
pars <- alfam2pars01[!grepl('man.ph', names(alfam2pars01))]
alfam2_predictions =  alfam2 (
pars = pars,
dat = data_alfam2 %>% select (- j.NH3, - e.cum, - e.rel, - dataset, - country),
app.name = "tan.app",
time.name = "time",
time.incorp = "t.incorp",
group = "pmid",
prep = TRUE
)
?alfam2
packageVersion("ALFAM2")
?`library
?library
sessionInfo()
